---
title: "Correction live EM GMM1d"
format: html
---



# Question 1:

```{r init-em}
data<-data.frame(Var=c(-3.3,-4.4,-1.9,3.3,2.5,3.2,0.3,0.1,-0.1,-0.5),
partition1=c(1,1,1,2,2,2,2,2,1,1),
partition2=c(1,3,2,1,3,2,1,3,2,1)
)# partition = c("CLuster1", "Cluster1", "Cluster2")
initEM <- function(x, partition) {
  
  param = list(pi = NA, theta = list())
  K = length(unique(partition))
  n = length(x)  
  
  nks = table(partition)
  param$pi = nks / n
  param$theta$mu = rep(0, K)
  param$theta$sigma2 = rep(0, K)
  for (k in 1:K) {
    nk = nks[k]
    # pi[k] = sum(partition == k) / n
    # nk = sum(partition == k)
    param$theta$mu[k] = mean(x[partition == k])
    param$theta$sigma2[k] = ((nk-1) / nk) * var(x[partition == k])
  }
  
  return(param)
}

initEM(x = data$Var, partition = data$partition2)
```

```{r e-step}

logsumexp = function(logx) {
  # compute log(sum(exp(logx)))
  # in a numerically stable fashion
  m = max(logx)
  return(m + log(sum(exp(logx - m))))
}

# a test
logx = c(-1000, -10000)
logsumexp(logx)
log(sum(exp(logx)))

Estep <- function(x, param) {
  n = length(x)
  K = length(param$pi)
  
  logtau = matrix(0, n, K)
  
  # Option 1:
  # for (i in 1:n) {
  #   for(k in 1:K) {
  #     logtau[i, k] = log(param$pi[k]) + 
  #       dnorm(x = x[i], 
  #             mean = param$theta$mu[k],
  #             sd = sqrt(param$theta$sigma2[k]), 
  #             log = T)
  #   }
  #   logtau[i,] = logtau[i,] - logsumexp(logtau[i,])
  # }
  
  # Option 2: eviter la boucle sur 1:n
  # use vectorization of dnorm()
  for (k in 1:K) {
    logtau[,k] = log(param$pi[k]) +
             dnorm(x = x, 
              mean = param$theta$mu[k],
              sd = sqrt(param$theta$sigma2[k]), 
              log = T)
  }
  # normalize the rows
  logtau = logtau - apply(logtau, 1, logsumexp)
  return(logtau)
}

# test Estep
init_param = initEM(data$Var, data$partition1)
logtau_init = Estep(data$Var, param=init_param)
logtau_init
exp(logtau_init) |> rowSums()
```

